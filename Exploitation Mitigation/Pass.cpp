#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Type.h"
#include <stdlib.h>
using namespace llvm;

namespace {
    struct CS6265 : public FunctionPass {
        static char ID;
        CS6265() : FunctionPass(ID) {}
        virtual bool runOnFunction(Function &F) {
	    errs() << "Processing Function: ";
            errs().write_escaped(F.getName()) << '\n';
	    srand(time(NULL));
	    for(Function::iterator bBlock = F.begin(), bBlockEnd = F.end(); bBlock != bBlockEnd; ++bBlock)
	    {
	        for(BasicBlock::iterator inst = bBlock->begin(), instEnd = bBlock->end(); inst != instEnd; ++inst)
		{	
                    if(AllocaInst * ai = dyn_cast<AllocaInst>(inst))
		    {		
			errs()<<"Alloca Inst Found: "<< *inst<<"\n";
			ArrayType * ArrInt32Ty = ArrayType::get(Type::getInt32Ty(getGlobalContext()), rand()%64+16); 
		        bBlock->getInstList().insert((Instruction *)inst, new AllocaInst(ArrInt32Ty, 0, "arr"));
		    }
		}
	    }
            return false;
        }
    };
}

char CS6265::ID = 0;
static RegisterPass<CS6265> X("cs6265", "CS6265 Security Pass", false, false);
